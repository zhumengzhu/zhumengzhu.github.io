[{"content":"要点简介：\n服务规模：40台4C8G机器的生产级模型推理集群 业务基准：稳定支撑1万QPS，服务SLA要求50ms@TP9999 问题特征：无代码变更的情况下出现性能断崖 引发思考：看似稳定的系统为何会突然性能劣化？ Previous Next \u0026nbsp; \u0026nbsp; / [pdf] View the PDF file here. ","date":"2024-07-19T11:30:00+08:00","permalink":"https://zhumengzhu.github.io/2024/07/in-depth-jvm-performance-tuning-guide/","title":"JVM性能调优实战分享"},{"content":"背景 staging 环境，某个车联网服务内存出现了内存泄露，相关同学在 06-14 及 06-15 两天分别采集了两个 dump 文件，以下简单记录分析过程。\n内存泄露最常用的排查工具是 Eclipse Memory Analyzer (MAT)，使用 MAT 打开两个 dump 文件。\n首先看 Leak Suspects 疑点一：JarFile org.springframework.boot.loader.jar.JarFile 是 Spring Boot 的类加载器，用于加载 jar 包。\n猜测此问题与 Druid issue-3808 类似：\n所有 jar 包被加载的次数几乎相同； 内存 dump 中相关对象的数量只有几千个，和请求量无关，更像是某些定时任务在做类加载： 06-14 的 dump 中加载次数约为 3250； 06-15 的 dump 中加载次数约为 1260； 可以通过升级或降级 mysql-connector-java 版本进行验证。\n疑点二：LockPubSub org.redisson.pubsub.LockPubSub 是 Redisson 的分布式锁实现，用于分布式锁的订阅和消息通知：加锁对象如果已经被锁定需要等待的时候，通过 pubsub 订阅消息注册一个 listener 来等待锁资源。\n分析 06-14 的内存 dump，发现 key 7e5axxxc00:gateway:xx:zz:msg:task:lock:c53fxxxaa13a 的 listeners 达到 33206 个，内存占用达到 1.32 GB。\n此问题与 redisson-issues-3577有些相似，但我在日志中没有找到这个服务锁的 timeout 日志（可能因为业务代码没打印），而只有获取锁失败的日志。\n另外，业务日志中只有释放锁的日志，而没有加锁的日志(也可能因为业务代码没打印)。 进一步分析 1、对内存泄露部分的 char 数组进行聚合的结果（2.12 GB 的内存泄露，日志信息 1.66GB，占比接近 80%）： 2、其中一个 char 数组到 gc roots 的路径： 这也是内存泄露的路径：OpenTelemetry 在做链路追踪时，会将一次 gRPC、HTTP 调用或 MQ 消费过程中的 Metrics 以及日志信息都放到它的 Context 对象中，这次调用或消费不结束，这些内存就会被引用而释放；业务使用分布式锁的方式可能存在问题，导致很多请求无法结束，大量对象存活无法释放。\n3、以下为该服务打印日志的频率监控\u0026mdash;-每分钟几千条日志。 4、另外通过Kibana 查询发现，有很多动辄几十 KB 的业务日志（敏感数据就不贴图了）。 5、服务的 GC 信息 综合上述信息，可以确定服务内存泄露，高概率是大日志导致的。\n解决方法 升级或降级 mysql-connector-java 版本 避免大日志 参考资料 Redis分布式锁-这一篇全了解(Redission实现分布式锁完美方案) https://github.com/redisson/redisson/issues/4216 https://github.com/redisson/redisson/issues/4294 ","date":"2023-07-17T11:46:30+08:00","permalink":"https://zhumengzhu.github.io/2023/07/memory-leak-issue-in-a-service/","title":"记一次某服务内存泄露问题"},{"content":"Q1、JDK 和 JRE 的区别 答：JDK 是 JRE 的父集，我们 POD 中需要安装 JDK，以便能运行一些诊断工具。\nJDK(Java Development Kit，Java 开发工具包) ，是整个JAVA的核心，包括了Java运行环境JRE（Java Runtime Envirnment），一堆Java工具（javac/java/jdb等）和Java基础的类库），包含JVM标准实现及Java核心类库。 JRE(Java Runtime Environment Java 运行环境) ，是 JDK 的子集，也就是包括 JRE 所有内容，以及开发应用程序所需的编译器和调试器等工具。 见：https://docs.oracle.com/javase/8/docs/ Q2、Oracle JDK 究竟从哪个版本开始收费？ 答：jdk8u201 和 jdk8u202 是 orcale jdk8 最后的免费版本，从 jdk8u211 和 jdk8u212 开始收费。参考：https://www.cnblogs.com/xuruiming/p/12881503.html\n如果使用 Orcale JDK，建议 jdk8u201: Q3、如何下载 Orcale JDK 8u201? 答：从 Oracle 官网下载：https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html\nQ4、Oracle JDK8u 和 OpenJDK8u 有什么区别？ 答：最主要的是授权协议不同。Orcale 的高版本商用时收费，OpenJDK 则完全免费。\n其次还有OpenJDK源代码不完整、部分源代码用开源代码替换、OpenJDK只包含最精简的JDK等问题，但一般来说，这些影响可以忽略。\nQ5、JDK8 的支持到什么时候结束？ 答：2030年12月31日，https://endoflife.date/java Q6、OpenJDK 支持 Java Flight Recorder 吗？ 答：支持，见：低延迟 Profile 工具 Flight Recorder 被移植到 Java 8。\n开启方法：\n1 -XX:+UnlockCommercialFeatures -XX:+FlightRecorder Q7、OpenJDK8 中的 Java Flight Recorder 是商用特性吗？ 答：不是，该特性在 OpenJDK 是完全免费的，见：Get started with JDK Flight Recorder in OpenJDK 8u。\n但要注意：Oracle 的 JDK11 之前的版本中 JFR 是商用特性，所以需要加 -XX:+UnlockCommercialFeatures 开启；同时为了兼容性，使用 OpenJDK 也要添加该参数。\nQ8、OpenJDK8 支持识别 Docker 容器的资源限制吗？ 答：取决于版本。\n比如：从 jdk8u191 开始完整支持，不需要需要使用 -XX:ParallelGCThreads=4 -XX:ConcGCThreads=1 -XX:G1ConcRefinementThreads=5 -XX:ActiveProcessorCount=8 这些参数指定 GC 线程数。\n详见：JVM 对容器化支持的参数（强烈建议，参考该文章在 docker 中进行验证）。\n小于 jdk8u131 版本不支持； 大于等于 jdk8u131，小于 jdk8u191 实验性支持； 大于等于 jdk8u191 开始完整的支持； Q9、如何下载 OpenJDK8？ 答： 很多，这里给出两个：Azul Zulu Downloads，OpenLogic OpenJDK Downloads 。\n特别地，如果是在个人开发电脑，则强烈建议使用 SDKMAN ，它支持并行版本管理，Java 生态的各种软件包，包括 JDK、、Kotlin、Groovy、Scala、Maven、Gradle 等等。\n","date":"2023-07-11T12:35:11+08:00","permalink":"https://zhumengzhu.github.io/2023/07/oracle-jdk-vs-openjdk-selection-guide/","title":"Oracle JDK 和 OpenJDK 如何选择？"},{"content":"参数建议 这些建议基于以下前提：\n服务器 CPU 支持超线程，即一个核可以当成两个核用，否则，GC 线程相关参数值应该减半； 如果 JDK 版本小于 1.8.0_191-b12(如JDK 1.8.0_151)，则需要设置 -XX:ParallelGCThreads=n, -XX:ConcGCThreads=n, -XX:G1ConcRefinementThreads=n 三个参数； 如果 JDK 版本升级到 1.8.0_191-b12 及以上，则最好不要设置上述三个参数，改为设置 -XX:+UnlockExperimentalVMOptions -XX:ActiveProcessorCount=n，n 取容器核数； 统一设置的参数 -XX:+UseG1GC 使用垃圾优先(G1)收集器 -XX:+PrintFlagsFinal 打印所有参数的最终值（参考：Java -XX:+PrintFlagsFinal命令行参数详解） -XX:+PrintCommandLineFlags 是打印那些被新值覆盖的项 -XX:+PrintStringTableStatistics 在 JVM 进程退出时会输出 SymbolTable 统计和 StringTable 统计（参考：聊聊jvm的StringTable及SymbolTable） -XX:+PrintGC 打印GC日志 -XX:+PrintGCDetails 打印详细的GC日志，还会在退出前打印堆的详细信息 -XX:+PrintGCDateStamps 打印CG发生的日期时间 -XX:+PrintGCTimeStamps 打印CG发生的相对时间戳 -XX:+PrintHeapAtGC 每次GC前后打印堆信息 -XX:+PrintTenuringDistribution YGC 时，打印出幸存区中对象的年龄分布 -XX:+PrintAdaptiveSizePolicy 打印分代大小调整的信息 -XX:+PrintGCApplicationStoppedTime 打印应用由于GC而产生的停顿时间 -XX:+PrintGCApplicationConcurrentTime 打印应用程序的执行时间 -XX:+PrintReferenceGC 打印软引用、弱引用、虚引用和Finallize队列处理情况 -XX:ParallelRefProcEnabled 启用并行引用处理 -XX:-OmitStackTraceInFastThrow 禁用 FastThrow 优化。如果开启，会导致抛出异常时没有堆栈信息，不利于排查问题。 -Xloggc:/app/logs/gc_$HOSTNAME.log GC 日志路径 -XX:GCLogFileSize=30M GC 日志文件大小 -XX:+UseGCLogFileRotation 启用 GC 日志文件滚动策略，需要先设置 -Xloggc -XX:NumberOfGCLogFiles=10 设置滚动日志时的文件数 -XX:+HeapDumpOnOutOfMemoryError 当发生 OOM 时，自动生成 dump 文件 -XX:HeapDumpPath=\u0026quot;/app/logs/java_%p_$HOSTNAME.hprof\u0026quot; 指定 dump 文件的路径 -XX:ErrorFile=/app/logs/hs_err_%p_$HOSTNAME.log 错误发生时，错误数据的存储路径 -Djava.security.egd=file:/dev/./urandom 加快随机数产生过程 允许调整的参数 -Xms2g -Xms4g total_memory / 2 最小堆内存，JVM 初始化时就会分配的堆内存大小。 -Xmx2g -Xms4g total_memory / 2 最大堆内存 -XX:MaxDirectMemorySize=512m -XX:MaxDirectMemorySize=512m - 设置最大直接内存（参考 JVM源码分析之堆外内存完全解读） -XX:MaxMetaspaceSize=512m -XX:MaxMetaspaceSize=512m - 设置最大元空间（参考JVM源码分析之Metaspace解密） -XX:MaxGCPauseMillis=200 -XX:MaxGCPauseMillis=200 - 设置最大GC暂停时间的目标。这是一个软目标，JVM将尽最大努力实现它。默认 200ms。 -XX:ParallelGCThreads=4 -XX:ParallelGCThreads=8 - 设置垃圾回收器并行阶段使用的线程数。计算公式见JVM调优系列: 默认GC线程数的计算公式 -XX:ConcGCThreads=1 -XX:ConcGCThreads=2 - 设置垃圾回收器并发阶段使用的线程数 -XX:G1ConcRefinementThreads=5 -XX:G1ConcRefinementThreads=9 ParallelGCThreads+1 设置并发优化线程，只专注扫描日志缓冲区记录的卡片来维护更新 RSet -XX:G1ReservePercent=10 -XX:G1ReservePercent=10 - 设置要保持空闲的预留内存的百分比，以减少空间溢出的风险。 默认值是10%。 当增加或减少这个百分比时，请确保对Java堆总量进行相同的调整。 -XX:InitiatingHeapOccupancyPercent=45 -XX:InitiatingHeapOccupancyPercent=45 - 启动并发GC周期的(整个)堆占用的百分比。 它由基于整个堆占用情况触发并发GC周期的GC使用，而不仅仅是其中的一个代(例如G1)。 值为0表示“执行恒定的GC周期”。 缺省值为45。 -XX:SoftRefLRUPolicyMSPerMB=1000 -XX:SoftRefLRUPolicyMSPerMB=1000 - 每1M空闲空间可保持的SoftReference对象生存的时长（单位ms）（参考：一次 JVM FullGC 的排查过程及解决方案！） 不建议设置的参数 不设置 -XX:+DisableExplicitGC，这样允许业务使用 System.gc() 在某些特定情况下主动 FullGC； 不要指定 -Xmn 参数，让 G1 自己去调整；如果设置了年轻代大小，会导致 G1 无法使用暂停时间目标； 完整参数示例 以下针对 4C8G 机器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 -Xms4g -Xmx4g -XX:MaxDirectMemorySize=512m -XX:MaxMetaspaceSize=512m -XX:+PrintFlagsFinal -XX:+PrintCommandLineFlags -XX:+PrintStringTableStatistics -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:ParallelGCThreads=8 -XX:ConcGCThreads=2 -XX:G1ConcRefinementThreads=9 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -XX:+PrintTenuringDistribution -XX:+PrintAdaptiveSizePolicy -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCApplicationConcurrentTime -XX:G1ReservePercent=10 -XX:InitiatingHeapOccupancyPercent=45 -XX:SoftRefLRUPolicyMSPerMB=1000 -XX:+PrintReferenceGC -XX:ParallelRefProcEnabled -Xloggc:/app/logs/gc_$HOSTNAME.log -XX:GCLogFileSize=30M -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=\u0026#34;/app/logs/java_%p_$HOSTNAME.hprof\u0026#34; -XX:ErrorFile=/app/logs/hs_err_%p_$HOSTNAME.log -XX:-OmitStackTraceInFastThrow -Djava.security.egd=file:/dev/./urandom 其它 建议升级 JDK 至少到 1.8.0_191-b12 及以上，原因参考 JVM如何获取当前容器的资源限制？ 和 云原生架构：容器资源限制及资源可见性 参考资料 Java HotSpot VM Options 10 Garbage-First Garbage Collector Tuning Collecting and reading G1 garbage collector logs - part 2 JVM性能——JVM调优参数列表 详解 G1 垃圾收集器 JVM之G1回收器和常见参数配置 ","date":"2023-06-18T12:18:18+08:00","permalink":"https://zhumengzhu.github.io/2023/06/jvm-parameter-recommendations-and-reasons/","title":"JVM 参数建议及理由"},{"content":"Contention in java.util.Random it\u0026rsquo;s thread-safe it\u0026rsquo;s lock-free To better understand this, let\u0026rsquo;s see how one of its primary operations, next(int), is implemented:\n1 2 3 4 5 6 7 8 9 protected int next(int bits) { long oldseed, nextseed; AtomicLong seed = this.seed; do { oldseed = seed.get(); nextseed = (oldseed * multiplier + addend) \u0026amp; mask; } while (!seed.compareAndSet(oldseed, nextseed)); return (int)(nextseed \u0026gt;\u0026gt;\u0026gt; (48 - bits)); } Instead of a dedicated instance of Random per thread, each thread only needs to maintain its own seed value. As of Java 8, the Thread class itself has been retrofitted to maintain the seed value:\n1 2 3 4 5 6 7 8 9 10 11 12 public class Thread implements Runnable { // omitted @jdk.internal.vm.annotation.Contended(\u0026#34;tlr\u0026#34;) long threadLocalRandomSeed; @jdk.internal.vm.annotation.Contended(\u0026#34;tlr\u0026#34;) int threadLocalRandomProbe; @jdk.internal.vm.annotation.Contended(\u0026#34;tlr\u0026#34;) int threadLocalRandomSecondarySeed; } The threadLocalRandomSeed variable is responsible for maintaining the current seed value for ThreadLocalRandom. Moreover, the secondary seed, threadLocalRandomSecondarySeed, is usually used internally by the likes of ForkJoinPool.\nThis implementation incorporates a few optimizations to make ThreadLocalRandom even more performant:\nAvoiding false sharing by using the @Contented annotation, which basically adds enough padding to isolate the contended variables in their own cache lines Using sun.misc.Unsafe to update these three variables instead of using the Reflection API Avoiding extra hashtable lookups associated with the ThreadLocal implementation Contention in java.util.SecureRandom it\u0026rsquo;s the subclass of java.util.Random\none of the most common locking issues within Java applications is triggered through an innocent-looking java.io.File.createTempFile() calls. Under the hood, this temporary file creation is relying upon a SecureRandom class to calculate the name of the file.\n1 2 3 4 5 6 7 8 9 10 private static final SecureRandom random = new SecureRandom(); static File generateFile(String prefix, String suffix, File dir) { long n = random.nextLong(); if (n == Long.MIN_VALUE) { n = 0; // corner case } else { n = Math.abs(n); } return new File(dir, prefix + Long.toString(n) + suffix); } And SecureRandom, when nextLong is called, eventually calls its method nextBytes(), which is defined as synchronized:\n1 2 3 synchronized public void nextBytes(byte[] bytes) { secureRandomSpi.engineNextBytes(bytes); } One may say, that if I create new SecureRandom in each thread, I will not get any issues. Unfortunately, it’s not that simple. SecureRandom uses an implementation of java.security.SecureRandomSpi, which will eventually be contended anyhow (you may look at the following bug discussion with some benchmarks in Jenkins issue tracker)\nThis in combination with certain application usage patterns (especially if you have lots of SSL connections which rely on SecureRandom for their crypto-handshaking magic) has a tendency to build up into long-lasting contention issues.\nThe fix to the situation is simple if you can control the source code – just rebuild the solution to rely upon the java.util.ThreadLocalRandom for multithreaded designs. In cases where you are stuck with a standard API making the decisions for you the solution can be more complex and require significant refactoring.\nurandom and random Devices https://www.ibm.com/docs/en/aix/7.2?topic=files-urandom-random-devices\nLinux Kernel 5.8 之前的版本，如果熵池的数据不足，从 /dev/random 读取数据可能阻塞，但是从 /dev/urandom 不会阻塞。Java 程序一般会指定 -Djava.security.egd=file:/dev/./urandom 参数避免阻塞的发生(但不一定生效)。 需要注意的是，\n-Djava.security.egd=file:/dev/urandom 是错误的； -Djava.security.egd=file:/dev/./urandom 才是正确的； 见：https://stackoverflow.com/questions/137212/how-to-deal-with-a-slow-securerandom-generator 关于性能 ThreadLocalRandom 和 SecureRandom 都是 Random 的子类； 性能：ThreadLocalRandom \u0026gt; Random \u0026gt; SecureRandom； Random 和 ThreadLocalRandom 使用的都是「线性同余发生器」算法，速度很快，区别是： Random 使用 CAS 方式更新种子，高并发情况下竞争大，性能会下降； ThreadLocalRandom 将种子存在在 Thread 对象上，性能更好： 种子封闭在线程内，不需要 CAS； 避免额外的『间接』计算： 相比 ThreadLocal + Random，在 Java8 中，ThreadLocalRandom 只需要直接读取存储在 Thread 对象上的 threadLocalRandomSeed 然后直接更新就可以，不需要调用 ThreadLocal.get 进行一次 HashTable Lookup； 通过 UNSAFE 的 native 方法更新种子值，而不是反射，效率更高； 通过使用 Contended 注解，避免伪共享问题； SecureRandom 使用 OS 维护的随机数据来生成随机数，底层会使用 synchronized 锁，因此性能比较差，且可能发生阻塞； SecureRandom 使用的某些算法，需要读取 /dev/random 来获取随机数据，当 OS 维护的熵池中的熵不足时，会发生阻塞，导致严重的性能问题； 在 Linux 的 v5.6 及其以后的内核中，读取 /dev/random 不会再被阻塞了，但是就像 /dev/urandom 一样，在一个全新的系统刚启动时由于系统尚未产生熵值，此时还是可能阻塞等待足够的熵值产生； UUID.randomUUID 底层使用的就是 SecureRandom，因此性能会比较差； File.createTempFile 底层也会使用 SecureRandom，因此性能会比较差； 建立 SSL 连接同样依赖 SecureRandom，因此也要小心； 如何预测下一个随机数 以下方法仅对基于 LCG 算法有效，利用公式 𝑋𝑛+1=(𝑎𝑋𝑛+𝑐) mod 𝑚。\n给定两个连续的 int 类型值，或一个 double，或一个 long 类型值，即可预测后续的随机数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 Predict Next Random Number.java import java.util.ArrayList; import java.util.Random; public class ReplicatedRandom extends Random { public static void main(String[] args) { predictByNextDouble(); predictByNextInt(); } private static void predictByNextInt() { long seed = System.currentTimeMillis(); Random r = new Random(seed); int v1 = r.nextInt(); int v2 = r.nextInt(); ReplicatedRandom rr = new ReplicatedRandom(); rr.replicateState(v1, v2); System.out.println(r.nextInt() == rr.nextInt()); // True System.out.println(r.nextInt() == rr.nextInt()); // True System.out.println(r.nextInt() == rr.nextInt()); // True } private static void predictByNextDouble() { long seed = System.currentTimeMillis(); Random r = new Random(seed); ReplicatedRandom rr = new ReplicatedRandom(); rr.replicateState(r.nextDouble()); System.out.println(r.nextDouble() == rr.nextDouble()); // True System.out.println(r.nextDouble() == rr.nextDouble()); // True System.out.println(r.nextDouble() == rr.nextDouble()); // True } // Replicate the state of a Random using a single value from its nextDouble public boolean replicateState(double nextDouble) { // nextDouble() is generated from ((next(26) \u0026lt;\u0026lt; 27) + next(27)) / (1L \u0026lt;\u0026lt; 53) // Inverting those operations will get us the values of next(26) and next(27) long numerator = (long) (nextDouble * (1L \u0026lt;\u0026lt; 53)); int first26 = (int) (numerator \u0026gt;\u0026gt;\u0026gt; 27); int last27 = (int) (numerator \u0026amp; ((1L \u0026lt;\u0026lt; 27) - 1)); return replicateState(first26, 26, last27, 27); } // Replicate the state of a Random using a single value from its nextLong public boolean replicateState(long nextLong) { int last32 = (int) (nextLong \u0026amp; ((1L \u0026lt;\u0026lt; 32) - 1)); int first32 = (int) ((nextLong - last32) \u0026gt;\u0026gt; 32); return replicateState(first32, 32, last32, 32); } // Replicate the state of a Random using two consecutive values from its nextInt public boolean replicateState(int firstNextInt, int secondNextInt) { return replicateState(firstNextInt, 32, secondNextInt, 32); } // Replicate the state of a Random using two consecutive values from its nextFloat public boolean replicateState(float firstNextFloat, float secondNextFloat) { return replicateState((int) (firstNextFloat * (1 \u0026lt;\u0026lt; 24)), 24, (int) (secondNextFloat * (1 \u0026lt;\u0026lt; 24)), 24); } public boolean replicateState(int nextN, int n, int nextM, int m) { // Constants copied from java.util.Random final long multiplier = 0x5DEECE66DL; final long addend = 0xBL; final long mask = (1L \u0026lt;\u0026lt; 48) - 1; long upperMOf48Mask = ((1L \u0026lt;\u0026lt; m) - 1) \u0026lt;\u0026lt; (48 - m); // next(x) is generated by taking the upper x bits of 48 bits of (oldSeed * multiplier + addend) mod (mask + 1) // So now we have the upper n and m bits of two consecutive calls of next(n) and next(m) long oldSeedUpperN = ((long) nextN \u0026lt;\u0026lt; (48 - n)) \u0026amp; mask; long newSeedUpperM = ((long) nextM \u0026lt;\u0026lt; (48 - m)) \u0026amp; mask; // Bruteforce the lower (48 - n) bits of the oldSeed that was truncated. // Calculate the next seed for each guess of oldSeed and check if it has the same top m bits as our newSeed. // If it does then the guess is right and we can add that to our candidate seeds. ArrayList\u0026lt;Long\u0026gt; possibleSeeds = new ArrayList\u0026lt;Long\u0026gt;(); for (long oldSeed = oldSeedUpperN; oldSeed \u0026lt;= (oldSeedUpperN | ((1L \u0026lt;\u0026lt; (48 - n)) - 1)); oldSeed++) { long newSeed = (oldSeed * multiplier + addend) \u0026amp; mask; if ((newSeed \u0026amp; upperMOf48Mask) == newSeedUpperM) { possibleSeeds.add(newSeed); } } if (possibleSeeds.size() == 1) { // If there\u0026#39;s only one candidate seed, then we found it! setSeed(possibleSeeds.get(0) ^ multiplier); // setSeed(x) sets seed to `(x ^ multiplier) \u0026amp; mask`, so we need another `^ multiplier` to cancel it out return true; } if (possibleSeeds.size() \u0026gt;= 1) { System.out.println(\u0026#34;Didn\u0026#39;t find a unique seed. Possible seeds were: \u0026#34; + possibleSeeds); } else { System.out.println(\u0026#34;Failed to find seed!\u0026#34;); } return false; } } 说明：\n上面的算法利用了 Java 生成的随机数有 48 个有效位这一信息； 对于 nextInt 来说，返回值是 32 位，因此在返回结果时，会舍弃低 16 位，这是通过 \u0026raquo;\u0026gt; 位移操作实现的； 对于 nextLong 来说，它是由两个连续的 nextInt 组成的； 对于 nextDouble 来说，它是由两个连续的分别是 27 bits 和 26 bits 数字组成的； 因此，当给定一个 nextInt 值时，将其左移 16 位，即得到种子的最小可能值，该值加上 2^16 - 1，就是种子的最大可能值；因此，只需遍历该空间(包含 2^16 个数字)，即可推测出种子的实际值； 现代 CPU 可以在 1 秒内用暴力方法逆向的推测出当前的种子值； Benchmark 单线程结果： 4 线程结果： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 RandomBenchmark.java package benchmark; import org.openjdk.jmh.annotations.Benchmark; import org.openjdk.jmh.annotations.BenchmarkMode; import org.openjdk.jmh.annotations.Fork; import org.openjdk.jmh.annotations.Measurement; import org.openjdk.jmh.annotations.Mode; import org.openjdk.jmh.annotations.OutputTimeUnit; import org.openjdk.jmh.annotations.Scope; import org.openjdk.jmh.annotations.State; import org.openjdk.jmh.annotations.Threads; import org.openjdk.jmh.annotations.Warmup; import org.openjdk.jmh.results.format.ResultFormatType; import org.openjdk.jmh.runner.Runner; import org.openjdk.jmh.runner.RunnerException; import org.openjdk.jmh.runner.options.Options; import org.openjdk.jmh.runner.options.OptionsBuilder; import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; import java.util.Random; import java.util.concurrent.ThreadLocalRandom; import java.util.concurrent.TimeUnit; /** */ @BenchmarkMode({Mode.AverageTime, Mode.Throughput}) @Warmup(iterations = 3, time = 1) @Measurement(iterations = 5, time = 5) @Threads(4) @Fork(1) @State(value = Scope.Benchmark) @OutputTimeUnit(TimeUnit.NANOSECONDS) public class RandomBenchmark { private final Random random = new Random(); private final ThreadLocal\u0026lt;Random\u0026gt; simpleThreadLocal = ThreadLocal.withInitial(Random::new); public static void main(String[] args) throws RunnerException { // 将结果文件上传到 https://jmh.morethan.io/ 可以得到可视化结果 String now = LocalDateTime.now().format(DateTimeFormatter.ofPattern(\u0026#34;yyyyMMddHHmmss\u0026#34;)); String filePath = \u0026#34;/tmp/jmh_result_\u0026#34; + now + \u0026#34;.json\u0026#34;; Options opt = new OptionsBuilder() .include(RandomBenchmark.class.getSimpleName()) .result(filePath) .resultFormat(ResultFormatType.JSON).build(); new Runner(opt).run(); } @Benchmark // @BenchmarkMode(Throughput) public int regularRandom() { return random.nextInt(); } @Benchmark // @BenchmarkMode(Throughput) public int simpleThreadLocal() { return simpleThreadLocal.get().nextInt(); } @Benchmark // @BenchmarkMode(Throughput) public int builtinThreadLocal() { return ThreadLocalRandom.current().nextInt(); } } Reference https://www.baeldung.com/java-thread-local-random https://alidg.me/blog/2020/4/24/thread-local-random https://stackoverflow.com/questions/11051205/difference-between-java-util-random-and-java-security-securerandom https://resources.infosecinstitute.com/topic/random-number-generation-java/ https://jazzy.id.au/2010/09/21/cracking_random_number_generators_part_2.html https://jazzy.id.au/2010/09/22/cracking_random_number_generators_part_3.html https://blogs.oracle.com/linux/post/rngd1 https://blogweb.cn/article/1642969777211 https://lwn.net/Articles/808575/ https://unix.stackexchange.com/questions/243127/how-to-check-if-reading-from-dev-random-will-block https://crypto.stackexchange.com/questions/51686/how-to-determine-the-next-number-from-javas-random-method https://franklinta.com/2014/08/31/predicting-the-next-math-random-in-java/ https://jazzy.id.au/2010/09/20/cracking_random_number_generators_part_1.html (讲解了破解随机数生成器的理论基础) ","date":"2023-01-30T10:33:47+08:00","permalink":"https://zhumengzhu.github.io/2023/01/java-random-number-issues-overview/","title":"Java 随机数问题综述"},{"content":"简介 本文从『优惠券发放』问题的讨论出发，介绍几个解决方案并分析其优缺点，然后讨论一下常见的update just one unused row模式，最后聊一下 MySQL 8.0.1 的 SKIP LOCKED 和 NOWAIT 特性。\n『券发放』问题 券发放，一般使用『预生成』模式。在发放前，先将券全部生成好，存在一张全表，这张表一般至少包含三个字段：\n一个全局唯一的券码字段； 一个状态字段表示是否发放； 一个用户 ID 字段记录券发给了谁； 当用户请求领券时，会从表中选择一条状态为『未领取』的记录，将其状态置为『已领取』，用户 ID置为『领券者的 ID』，最后将券码返给用户。\n假设券表结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 CREATE TABLE `coupon` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT \u0026#39;主键id\u0026#39;, `code` VARCHAR(64) NOT NULL DEFAULT \u0026#39;\u0026#39; COMMENT \u0026#39;唯一劵码\u0026#39;, `status` TINYINT(10) NOT NULL DEFAULT 0 COMMENT \u0026#39;劵状态, 0: 未领取，1：已领取，2：已核销\u0026#39;, `user_id` BIGINT(20) NOT NULL DEFAULT 0 COMMENT \u0026#39;用户 ID\u0026#39;, `create_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP, `update_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`id`), UNIQUE KEY `uk_code` (`code`), KEY `idx_status` (`status`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4 COMMENT =\u0026#39;优惠券表\u0026#39;; 券表中的数据如下：\nID CODE status user_id 1 c1 0 0 2 c2 0 0 3 c3 0 0 4 c4 0 0 5 c5 0 0 假设领券的用户 ID 为 1000。\n方法一：乐观锁-CAS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 1、选择一张券，假设选中的券码为 `c1`； SELECT * FROM coupon WHERE `status` = 0 LIMIT 1; # 2、修改券记录的状态 UPDATE coupon SET `status` = 1, `user_id` = 1000 WHERE `code` = \u0026#39;c1\u0026#39; AND `status` = 0; # 3、返回券码 `c1` 上述方法，在并发情况下可能存在问题：\n操作顺序 线程一 线程二 1 SELECT * FROM coupon WHERE status = 0 LIMIT 1; # 假设返回记录券码为 c1 2 SELECT * FROM coupon WHERE status = 0 LIMIT 1; # 假设返回记录券码也是 c1 3 UPDATE coupon SET status = 1, user_id = 1000 WHERE code = \u0026lsquo;c1\u0026rsquo; AND status = 0; # 成功 4 UPDATE coupon SET status = 1, user_id = 1000 WHERE code = \u0026lsquo;c1\u0026rsquo; AND status = 0; # 失败 由于线程一执行完第三步后，已将c1这条记录的status的值改为 1，因此线程二执行第四步会失败。所以需要重试。\n这可以看做一种『乐观锁』模式，『乐观锁』不适合高并发场景。\n方法二：悲观锁-SELECT FOR UPDATE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 1、开启事务（InnoDB 默认的 RR 级别） begin; # 2、选择一张券，假设选中的券码为 `c1`； SELECT * FROM coupon WHERE `status` = 0 LIMIT 1 FOR UPDATE; # 3、修改券记录的状态 UPDATE coupon SET `status` = 1, `user_id` = 1000 WHERE `code` = \u0026#39;c1\u0026#39; AND `status` = 0; # 4、提交事务 commit; # 5、返回券码 `c1` 为了解决并发的情况下某个操作失败， 可以开启一个事务，然后使用 select for update 先对记录进行加锁，然后再修改记录状态。 假设操作顺序如下：\n操作顺序 线程一 线程二 1 begin; 2 begin; 3 SELECT * FROM coupon WHERE status = 0 LIMIT 1 FOR UPDATE; # 假设返回记录券码为 c1 4 SELECT * FROM coupon WHERE status = 0 LIMIT 1 FOR UPDATE; # 阻塞 5 UPDATE coupon SET status = 1, user_id = 1000 WHERE code = \u0026lsquo;c1\u0026rsquo; AND status = 0; # 成功 6 commit; # 释放记录c1的锁 7 SELECT * FROM coupon WHERE status = 0 LIMIT 1; # 成功，返回券码 c2 8 UPDATE coupon SET status = 1, user_id = 1000 WHERE code = \u0026lsquo;c2\u0026rsquo; AND status = 0; # 成功 9 commit; # 释放记录c2的锁 线程二在执行第 4 步时，由于线程一已经抢到记录c1的锁，线程二会被阻塞，直到线程一提交事务（ 根据2PL，提交事务时才会释放锁）；线程二在 7 步获取锁后，由于记录c1的status的值已被线程一改为 1，所以此时查询到的记录是c2。\n方法二虽然可以保证券发放不会失败，但在高并发下，会有大量线程阻塞。\n方法三：使用 LAST_INSERT_ID 优化锁的持有时间 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 1、将状态为未领取的一张券发放给用户 UPDATE coupon SET `status` = 1, `user_id` = 1000, `id` = LAST_INSERT_ID(`id`) WHERE `status` = 0 LIMIT 1; # 2、查询步骤 1 修改的券的 ID，假设 id 为 1 SELECT LAST_INSERT_ID(); # 3、查询券码，假设券码值为 `c1` SELECT `code` FROM coupon WHERE id = 1; # 4、返回券码 `c1` 方法二中，根据 2PL（两阶段锁协议），锁的持有时间从 select for update 一直持续到 commit。 通过使用 LAST_INSERT_ID 可以避免开启事务，锁的持有时间非常短。\n不过这个方法没法避免锁争抢，因为根据 InnoDB 的锁机制，在扫描到满足条件的记录时会进行加锁(由于 idx_status 是非唯一索引，因此会加 next-key 锁) ，所以并发执行时仍然会存在阻塞的情况。\n这其实就是经典的**『热点数据更新』**问题。\n此外，要这个方法是 multi-user safe 的，所以在并发情况下也是安全的:\nIt is multi-user safe because multiple clients can issue the UPDATE statement and get their own sequence value with the SELECT statement (or mysql_insert_id()), without affecting or being affected by other clients that generate their own sequence values.\nsee MySQL 8.0 Reference Manual\n最后，还可以对上面的 SQL 进一步优化，使得只需执行 2 次 SQL：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 1、将状态为未领取的一张券发放给用户 UPDATE coupon SET `status` = 1, `user_id` = 1000, `id` = LAST_INSERT_ID(`id`) WHERE `status` = 0 LIMIT 1; # 2、查询券码 SELECT `code` FROM coupon, (SELECT LAST_INSERT_ID() id) AS t WHERE coupon.id = t.id; # 3、返回券码 `c1` 方法四：使用 SKIP LOCKED 避免锁争抢 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 1、开启事务（InnoDB 默认的 RR 级别） begin; # 2、是用 `SELECT FOR UPDATE SKIP LOCKED` 选择一条券 SELECT * FROM coupon WHERE `status` = 0 LIMIT 1 FOR UPDATE SKIP LOCKED; # 3、修改券记录的状态 UPDATE coupon SET `status` = 1, `user_id` = 1000 WHERE `code` = \u0026#39;c1\u0026#39; AND `status` = 0; # 4、提交事务 commit; # 5、返回券码 `c1` 假设操作顺序如下：\n操作顺序 线程一 线程二 1 begin; 2 begin; 3 SELECT * FROM coupon WHERE status = 0 LIMIT 1 FOR UPDATE SKIP LOCKED; # 假设返回记录券码为 c1 4 SELECT * FROM coupon WHERE status = 0 LIMIT 1 FOR UPDATE SKIP LOCKED; # 成功，返回券码 c2 5 UPDATE coupon SET status = 1, user_id = 1000 WHERE code = \u0026lsquo;c1\u0026rsquo; AND status = 0; # 成功 6 commit; # 释放记录c1的锁 8 UPDATE coupon SET status = 1, user_id = 1000 WHERE code = \u0026lsquo;c2\u0026rsquo; AND status = 0; # 成功 9 commit; # 释放记录c2的锁 不同于方法二，线程二在执行第 4 步时，不会阻塞在记录c1上，而是会跳过这条记录，直接对下一条记录c2进行加锁。\n这个方法，锁的持有时间与方法二相同，但避免了争抢锁，也能达到一个很好的性能。\n注意，SKIP LOCKED 是 MySQL 8.0.1 引入的新特性。\n方法五：使用 Redis 减少 SQL 的执行次数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 0、初始化 Redis: 在活动开始前，先从数据库中查询所有未发放券的券码，放入 Redis 中的队列中 LPUSH coupon_list_key (SELECT code from coupon WHERE status = 0) # 1、发放时，从 Redis 队列中移除并返回一个券码，假设值为`c1` LPOP coupon_list_key # 2、修改券记录的状态 UPDATE coupon SET `status` = 1, `user_id` = 1000 WHERE `code` = \u0026#39;c1\u0026#39; AND `status` = 0; # 3、返回券码 `c1` 使用 Redis，既能保证正确性，也有更好的性能，因为：\nRedis 是单线程执行命令的，因此从 Redis 返回的券码是唯一的，执行第 2 步不会争抢锁也不会失败； LPOP 命令是从队列头移除一个元素，时间复杂度仅为 O(1)； 仅需要执行一条 UPDATE 语句； 除此之外，还可以通过引入 MQ 将 UPDATE 语句改为异步执行，进一步提高并发度。\n不过，引入 Redis 会使得系统变得更复杂，因为：\n需要额外编写一个模块用来初始化 Redis； 在初始化 Redis 要特别小心，不能将『已发放』的券放入 Redis； 从 Redis 出队成功，但写数据库失败，会导致券码被浪费，需要回滚 Redis； 回滚 Redis 可能实现起来比较复杂，因为将券码放回 Redis 时可能失败，需要重试机； Redis 主从同步可能存在延迟，此时主从切换可能导致 Redis 返回重复的券码，导致方法失败，需要重试机制； 小节 方法一和方法二不适合高并发场景，前者失败率高，后者性能特别差； 方法三持有锁的时间很短，性能比较好，实现也很简单，但存在热点数据更新问题； 方法四持有锁的时间稍长，因为锁的是不同的记录，因此不存在热点数据，性能比较好，实现也简单，但只能在 MySQL 8.0.1 及以上才能使用； 方法五引入 Redis，在性能上有最大的潜力，但实现起来更复杂； 方法三、四、五孰优孰劣，留待实践进行检验。\nUpdate just one unused row 仅更新一行未使用的数据，是一种非常常见的场景，看似非常容易解决：\n1 2 3 4 5 # 乐观锁 CAS 更新 UPDATE record SET `status` = \u0026#39;used\u0026#39; WHERE `status` = \u0026#39;unused\u0026#39; LIMIT 1; 但当我们需要获取被更新数据的 ID 时，问题瞬间变得复杂起来。\n获取变更 ID，除了上面介绍的使用悲观锁SELECT FOR UPDATE和LAST_INSERT_ID两个方法外，还可以通过临时变量来实现：\nSET @update_id := 0; UPDATE some_table SET column_name = \u0026lsquo;value\u0026rsquo;, id = (SELECT @update_id := id) WHERE some_other_column = \u0026lsquo;blah\u0026rsquo; LIMIT 1; SELECT @update_id;\n详情见：How to get ID of the last updated row in MySQL?:\n这种方法在需要一次更新多条记录时特别有用。\nMySQL 8.0.1 SKIP LOCKED and NOWAIT 推荐一篇文章：MySQL 8.0.1: Using SKIP LOCKED and NOWAIT to handle hot rows 这篇文章是在 2017 年 4 月 12 由 Martin Hansson 发布在 MySQL 官方博客上的。它主要是通过一个订票系统，讲解 SKIP LOCKED 和 NOWAIT 的使用方法。\n另外，需要特别注意：\nStatements that use NOWAIT or SKIP LOCKED are unsafe for statement based replication.\nReference https://dba.stackexchange.com/questions/131051/update-just-one-unused-row https://stackoverflow.com/questions/1388025/how-to-get-id-of-the-last-updated-row-in-mysql https://gist.github.com/PieterScheffers/189cad9510d304118c33135965e9cddb https://dev.mysql.com/blog-archive/mysql-8-0-1-using-skip-locked-and-nowait-to-handle-hot-rows/ https://dev.mysql.com/doc/refman/8.0/en/information-functions.html#function_last-insert-id https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html ","date":"2022-11-20T17:21:39+08:00","permalink":"https://zhumengzhu.github.io/2022/11/mysql-update-just-one-unused-row/","title":"Mysql 只更新未使用的一行数据问题"},{"content":"背景 这是一篇博客阅读笔记，原博客Late row lookups: InnoDB写于 2011 年，作者是一个叫 Quassnoi 的俄罗斯人。\nQuassnoi 在 2009 年时写了一篇文章讲 MySQL Limit 的性能优化(MySQL ORDER BY / LIMIT performance: late row lookups)，后来有读者提了两个问题：\nIs this workaround specific to MyISAM engine? How does PostgreSQL handle this? Quassnoi 写下这篇新博客，即为了回答上述两个问题。\n正文 The questions concerns a certain workaround for MySQL LIMIT … OFFSET queries like this:\n1 2 3 4 SELECT * FROM mytable ORDER BY id LIMIT 10 OFFSET 10000; which can be improved using a little rewrite:\n1 2 3 4 5 6 7 8 SELECT m.* FROM (SELECT id FROM mytable ORDER BY id LIMIT 10 OFFSET 10000) q JOIN mytable m ON m.id = q.id ORDER BY m.id; 注意：作者之前的文章讨论的是这个方法对 MyISAM 是有效的；问题是，对于 InnoDB 和 PostgreSQL 呢？\nPostgreSQL The Answer The second questions is easy: PostgreSQL won\u0026rsquo;t pull the fields from the table until it really needs them. If a query involving an ORDER BY along with LIMIT and OFFSET is optimized to use the index for the ORDER BY part, the table lookups won\u0026rsquo;t happen for the records skipped.\n这句话是说，PostgreSQL 只会在需要的时候才回表查询。如果一个查询涉及 ORDER BY、LIMIT 和 OFFSET，那么可以先利用索引跳过不需要的记录，只对需要的记录进行进行回表。\n这其实就是『Late Row Lookups』；与之相对的，MySQL 执行的是『Early Row Lookups』。\n作者后面说虽然 PostgreSQL 的查询计划不会输出回表信息，但可以通过一个简单的测试进行验证。但具体怎么进行这个实验，作者没讲，下面试着做个补充。\n验证(存疑) 建表详情 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 -- 建表 CREATE TABLE page ( id SERIAL PRIMARY KEY, name VARCHAR(16) DEFAULT NULL, content VARCHAR(255) DEFAULT NULL ); -- 为 name 字段创建二级索引 CREATE INDEX idx_name ON page (name); -- 初始化 600 万条数据 INSERT INTO page (name, content) (SELECT CONCAT(\u0026#39;小瓦\u0026#39;, s.id) AS name, CONCAT(\u0026#39;xx\u0026#39;, s.id) AS content FROM GENERATE_SERIES(1, 6000010) AS s(id)); 执行 SQL 一：直接查询 1 2 3 4 5 6 7 postgres=# EXPLAIN ANALYZE SELECT * FROM page ORDER BY id OFFSET 6000000 LIMIT 10; QUERY PLAN ------------------------------------------------------------------------------------------------------------------------------------------ Limit (cost=199830.43..199830.76 rows=10 width=26) (actual time=540.002..540.003 rows=10 loops=1) -\u0026gt; Index Scan using page_pkey on page (cost=0.43..199846.81 rows=6000492 width=26) (actual time=0.087..427.982 rows=6000010 loops=1) Planning Time: 0.108 ms Execution Time: 540.022 ms 执行 SQL 二：使用子查询 1 2 3 4 5 6 7 8 9 10 11 postgres=# EXPLAIN ANALYZE SELECT t1.* FROM page t1, (SELECT id FROM page ORDER BY id OFFSET 6000000 LIMIT 10) t2 where t1.id=t2.id ORDER BY t1.id; QUERY PLAN ---------------------------------------------------------------------------------------------------------------------------------------------------- Nested Loop (cost=155811.47..155895.90 rows=10 width=26) (actual time=368.952..368.960 rows=10 loops=1) -\u0026gt; Limit (cost=155811.04..155811.30 rows=10 width=4) (actual time=368.941..368.942 rows=10 loops=1) -\u0026gt; Index Only Scan using page_pkey on page (cost=0.43..155823.81 rows=6000492 width=4) (actual time=0.015..248.584 rows=6000010 loops=1) Heap Fetches: 50 -\u0026gt; Index Scan using page_pkey on page t1 (cost=0.43..8.45 rows=1 width=26) (actual time=0.001..0.001 rows=1 loops=10) Index Cond: (id = page.id) Planning Time: 0.375 ms Execution Time: 369.004 ms 执行 SQL 三：使用子查询 1 2 3 4 5 6 7 8 9 10 11 postgres=# EXPLAIN ANALYZE SELECT t1.* FROM page t1 join (SELECT id FROM page ORDER BY id OFFSET 6000000 LIMIT 10) t2 ON t1.id=t2.id ORDER BY t1.id; QUERY PLAN ---------------------------------------------------------------------------------------------------------------------------------------------------- Nested Loop (cost=155811.47..155895.90 rows=10 width=26) (actual time=362.645..362.652 rows=10 loops=1) -\u0026gt; Limit (cost=155811.04..155811.30 rows=10 width=4) (actual time=362.633..362.634 rows=10 loops=1) -\u0026gt; Index Only Scan using page_pkey on page (cost=0.43..155823.81 rows=6000492 width=4) (actual time=0.017..243.148 rows=6000010 loops=1) Heap Fetches: 50 -\u0026gt; Index Scan using page_pkey on page t1 (cost=0.43..8.45 rows=1 width=26) (actual time=0.001..0.001 rows=1 loops=10) Index Cond: (id = page.id) Planning Time: 4.609 ms Execution Time: 362.707 ms 三个查询的耗时为：`540.022 ms` vs `369.004 ms` vs `362.707 ms`。 \u003e Tips: 使用 `EXPLAIN ANALYZE` 既可以获得查询计划，又能执行语句。 结论 上述实验可以证明该优化对于 PostgreSQL 同样可以有效。\nInnoDB 为了回答这个问题，作者首先创建了一张表。\n建表 建表详情 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 # 创建一张内存表 CREATE TABLE filler ( id INT NOT NULL PRIMARY KEY AUTO_INCREMENT ) ENGINE = Memory; # 创建 InnoDB 表 CREATE TABLE lookup ( id INT NOT NULL PRIMARY KEY, value INT NOT NULL, shorttxt TEXT NOT NULL, longtxt TEXT NOT NULL ) ENGINE = InnoDB ROW_FORMAT = COMPACT; # 为 value 字段创建索引 CREATE INDEX ix_lookup_value ON lookup (value); # 创建存储计划 DELIMITER $$ CREATE PROCEDURE prc_filler(cnt INT) BEGIN DECLARE _cnt INT; SET _cnt = 1; WHILE _cnt \u0026lt;= cnt DO INSERT INTO filler SELECT _cnt; SET _cnt = _cnt + 1; END WHILE; END $$ # 初始化内存表 DELIMITER ; START TRANSACTION; CALL prc_filler(100000); COMMIT; # 初始化 InnoDB 表 INSERT INTO lookup SELECT id, CEILING(RAND(20110211) * 1000000), RPAD(\u0026#39;\u0026#39;, CEILING(RAND(20110211 \u0026lt;\u0026lt; 1) * 100), \u0026#39;*\u0026#39;), RPAD(\u0026#39;\u0026#39;, CEILING(8192 + RAND(20110211 \u0026lt;\u0026lt; 1) * 100), \u0026#39;*\u0026#39;) FROM filler; 上面利用一张内存表和存储计划创建了一张 InnoDB 表 `lookup`：这张表包含一个加了索引的 `INT` 列，以及两个 `TEXT` 列，其中 shorttxt 存储短字符串(包含 1~100 个字符)，longtxt 存储长字符串(包含 8193~8293 个字符)。 通过主键索引查询 value 和 shottxt 两个字段时，是否使用子查询优化对耗时影响不大，略去不讨论。\n通过主键索引查询 longtxt 列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # Rewrite SELECT LENGTH(l.longtxt) FROM (SELECT id FROM lookup ORDER BY id LIMIT 10 OFFSET 90000) q JOIN lookup l ON l.id = q.id ORDER BY q.id; # 10 rows in set (0.133 sec) # No rewrite SELECT LENGTH(longtxt) FROM lookup ORDER BY id LIMIT 10 OFFSET 90000; # 10 rows in set (1.579 sec) 0.133 sec vs 1.579 sec。\nWhy such a difference?\nThe reason is that InnoDB, despite the fact it stores the data in the clustered index, is still able to move \u0026gt; some data out of the index. This is called external storage.\n在 InnoDB 中，小于 768 字节的列会全部存储在页上，大于 768 字节则会分开存储。在上面的 lookup 表中，shottxt 列总是 on-page 存储的，而 longtxt 则是 off-page的。\n因此，直接查询 longtxt 时，每扫描一条记录都要出发两次page lookups：第一次查聚簇索引，第二次查外部存储。这既会花费很多时间，也可能破坏 InnoDB 缓存，导致缓存命中率下降。\n通过二级索引查询 shorttxt 列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # Rewrite SELECT LENGTH(l.shorttxt) FROM (SELECT id, value FROM lookup ORDER BY value LIMIT 10 OFFSET 90000) q JOIN lookup l ON l.id = q.id ORDER BY q.value; # 10 rows in set (0.022 sec) # No rewrite SELECT LENGTH(shorttxt) FROM lookup ORDER BY value LIMIT 10 OFFSET 90000;# 10 rows in set (0.209 sec) 0.022 sec vs 0.209 sec，耗时相差 10 倍。 InnoDB的二级索引查询有点类似MyISAM，都需要一次额外的回表查询去获取正在的数据。\n上面第一个查询对于跳过的记录不会执行回表查询，因此速度是原来的 10 倍。它甚至比在主键索引上的查询(0.044 sec)还快，原因是二级索引包含的数据比主键索引更少，每页保存的数据更多，因此索引可能更加矮胖，扫描速度更快。\n当然，二级索引上同样是Early Row Lookups。\n结论 A trick used to avoid early row lookups for the LIMIT … OFFSET queries is useful on InnoDB tables too, though to different extent, depending on the ORDER BY condition and the columns involved:\nIt\u0026rsquo;s very useful on queries involving columns stored off-page (long TEXT, BLOB and VARCHAR columns) It\u0026rsquo;s very useful on ORDER BY conditions served by secondary indexes It\u0026rsquo;s quite useful on moderate sized columns (still stored on page) or CPU-intensive expressions It\u0026rsquo;s almost useless on short columns without complex CPU-intensive processing 其它 PostgreSQL查询计划 除第一行以外每个-\u0026gt;表示一个子动作 查询计划的阅读顺序都是从后往前 cost 由 .. 分割成两个数字，第一个数字表示启动成本，即返回第一行的成本；第二个数字表示返回所有数据的成本。 rows 表示返回行数 width 表示每行平均宽度 loops 表示索引扫描被执行过几次 Reference Documentation: 15: 14.1. Using EXPLAIN - PostgreSQL ","date":"2022-11-14T19:12:47+08:00","permalink":"https://zhumengzhu.github.io/2022/11/late-row-lookups-innodb/","title":"Late Row Lookups: InnoDB"},{"content":"一、深分页为什么慢 深分页指的是形如 select ... from ... where ... order by ... limit offset, size 的查询语句中 offset 特别大的情况。高性能 MySQL(第三版) 的第 6.7.5 节专门讲了此问题，但比较简略。\n有多慢 假设有一张 page 表包含 600 多万条数据，分别执行下面两条语句：\n1 2 3 4 5 6 7 # SQL 一 select * from page order by id limit 0, 10; # 10 rows in set (0.001 sec) # SQL 二 select * from page order by id limit 6000000, 10; # 10 rows in set (0.940 sec) 注意到 SQL 二其实是按主键 ID 排序的(意味着不需要进行 filesort，直接按主键索引顺序扫描即可)，耗时仍然高达 0.940 秒。\n为什么慢 『查询计划』\n1 2 3 4 5 6 explain select * from page order by id limit 6000000, 10; +------+-------------+-------+-------+---------------+---------+---------+------+---------+-------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +------+-------------+-------+-------+---------------+---------+---------+------+---------+-------+ | 1 | SIMPLE | page | index | NULL | PRIMARY | 4 | NULL | 5988448 | | +------+-------------+-------+-------+---------------+---------+---------+------+---------+-------+ 『慢查询日志』\n1 2 3 4 5 6 7 # Time: 221106 0:26:54 # User@Host: root[root] @ localhost [] # Thread_id: 18 Schema: test QC_hit: No # Query_time: 0.939618 Lock_time: 0.000735 Rows_sent: 10 Rows_examined: 6000010 # Rows_affected: 0 Bytes_sent: 533 SET timestamp=1667665614; select * from page order by id limit 6000000, 10; 注意到 rows 和 为 rows_examined 分别为 5988448、6000010。 原因显而易见：为了完成 limit offset, size 这样的查询， MySQL 要扫描至少 offset + size 行数据；offset 越大，则扫描次数越多，速度越慢。\n二、深分页怎么优化 分页从原理上来讲，主要是两种：\n一种就是前面讲的基于 limit offset, size 的分页，英文一般叫 offset pagination； 另一种方法放弃了 offset，改用 left off, SQL 形如 SELECT ... WHERE ... AND id \u0026lt; $left_off ORDER BY id DESC LIMIT 10, 英文一般叫 cursor pagination, 也有人称之为 seek method 或 keyset pagination。 Offset pagination 就像基于比较的排序算法的平均时间复杂度的下界是 O(nlogn) 一样，对于 MySQL 来说，凡是形如 limit offset, size 的查询，扫描次数的下限就是 offset + size，我们只能尽量逼近这个下限。 由于在主键索引上的优化比较复杂，同样的 SQL 对于不同的数据规模效果不一样，暂不讨论。这里主要分析在二级索引上的优化。\n对于拥有 600 多万条数据的 page 表：\n1 2 3 4 5 6 7 8 9 10 -- 原 SQL(强制走二级索引) select * from page force index(idx_name) order by name limit 6000000, 10; # 10 rows in set (4.833 sec) -- 优化方案一 select t1.* from page t1, (select id from page order by name limit 6000000, 10) t2 where t1.id = t2.id order by t1.name; # 10 rows in set (0.746 sec) -- 优化方案二 select t1.* from page t1 join (select id from page order by name limit 6000000, 10) t2 on t1.id = t2.id order by t1.name; # 10 rows in set (0.741 sec) 通过使用利用了覆盖索引的子查询，性能提升约 80%~90%：\nKeyset pagination 1 2 3 4 # First page (latest 10 items): SELECT ... WHERE ... ORDER BY id DESC LIMIT 10 # Next page (second 10): SELECT ... WHERE ... AND id \u0026lt; $left_off ORDER BY id DESC LIMIT 10 三、优化为什么有效 优化前 考虑原始 SQL select * from page force index(idx_name) order by name limit 6000000, 10 的执行过程：\n首先 Sever 层向 InnoDB 请求第一条数据；InnoDB 从 idx_name 上获取第一条二级索引记录，然后查询聚簇索引获取完整记录(即回表操作)，返回给 Server 层; 由于存在 limit 6000000 的限制, Server 层会将该数据丢弃并计数，然后向 InnoDB 请求下一条数据； 上述操作重复 600 万次； 之后的第 6000001~6000010 10 条数据则会被放入本地网络缓冲区，发给客户端； 问题在第 1 步的回表操作：\n回表首先意味着先读一次二级索引，然后读一次聚簇索引，因此记录的扫描总数实际会是 2 * 600 万次=1200 万次； 其次，回表操作可能需要一次磁盘随机读； 优化后 再考虑优化后的 SQL select t1.* from page t1 join (select id from page order by name limit 6000000, 10) t2 on t1.id = t2.id order by t1.name 的执行过程：\n首先 Sever 层向 InnoDB 请求第一条数据；InnoDB 从 idx_name 上获取第一条二级索引记录，然后查询聚簇索引获取完整记录(这一操作叫回表)，然后将主键 ID 返回给 Server 层; 由于存在 limit 6000000 的限制, Server 层会将该数据丢弃并计数，然后向 InnoDB 请求下一条数据； 上述操作重复 600 万次； 之后的第 6000001~6000010 10 条数据则会被放入内存缓冲区； 查询聚簇索引，获取 10 个主键 ID 对应的完整记录； 总结 在优化后：\n记录的总扫描次数从 1200 万次 减少到 600 万零 10 次； 磁盘随机读的次数从 600 万次 减少到 10 次； 四、试验方法 建表和数据初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 -- 建表 CREATE TABLE `page` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `name` VARCHAR(16) DEFAULT NULL, `content` VARCHAR(255) DEFAULT NULL, PRIMARY KEY (`id`), KEY `idx_name` (`name`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4; -- 创建存储过程用于初始化数据 DELIMITER ;; CREATE PROCEDURE init_page() BEGIN DECLARE i INT; SET i = 1; WHILE(i \u0026lt;= 6000010) DO INSERT INTO page (`name`, `content`) VALUES (CONCAT(\u0026#39;小瓦\u0026#39;, i), CONCAT(\u0026#39;xx\u0026#39;, i)); SET i = i + 1; END WHILE; END;; DELIMITER ; -- 调用存储过程 CALL init_page(); 启用慢查询日志 1 2 3 4 5 6 -- 启用慢查询日志 SET GLOBAL slow_query_log=1; -- 将慢查询时间阈值设置为 0.1 秒 SET GLOBAL long_query_time=0.1; -- 查看慢查询日志名 SHOW VARIABLES LIKE \u0026#39;%slow_query%\u0026#39;; 对比 SQL 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 -- 探索一级索引 --- 基础 SQL select * from page order by id limit 6000000, 10; --- 最慢 select * from page where id \u0026gt;= (select id from page order by id limit 6000000, 1) order by id limit 10; --- 最快 select t1.* from page t1, (select id from page order by id limit 6000000, 10) t2 where t1.id = t2.id order by t1.id; -- 探索二级索引 --- 基础 SQL，会是全表扫描，最慢 select * from page order by name limit 6000000, 10; --- 强制走二级索引，稍快 select * from page force index(idx_name) order by name limit 6000000, 10; --- 利用使用了覆盖索引的子查询，减少回表，最快 select t1.* from page t1, (select id from page order by name limit 6000000, 10) t2 where t1.id = t2.id order by t1.name; 查看慢查询日志和数据存储位置 1 2 3 4 5 6 # 查看 mysql 进程参数 ps aux | grep mysql # /opt/homebrew/opt/mariadb/bin/mariadbd --basedir=/opt/homebrew/opt/mariadb --datadir=/opt/homebrew/var/mysql --plugin-dir=/opt/homebrew/opt/mariadb/lib/plugin --log-error=/opt/homebrew/var/mysql/zmz.local.err --pid-file=zmz.local.pid # --basedir=/opt/homebrew/opt/mariadb 即慢查询日志和数据文件所在目录 # ps. 执行前面的存储计划，创建 100 万条数据，占用磁盘空间大约 100MB；创建 600 万条数据，占用空间大约 600MB； 五、References mysql查询 limit 1000,10 和limit 10 速度一样快吗？如果我要分页，我该怎么办？ 要想通过面试，MySQL的Limit子句底层原理你不可不知 MySQL Logical Architecture Mysql index configuration MySQL ORDER BY / LIMIT performance: late row lookups Late Row Lookups: InnoDB MySQL ORDER BY LIMIT Performance Optimization mysql 证明为什么用limit时，offset很大会影响性能 MySQL 5.7 Reference Manual/LIMIT Query Optimization Pagination Optimization We need tool support for keyset pagination ","date":"2022-11-05T12:36:01+08:00","permalink":"https://zhumengzhu.github.io/2022/11/mysql-order-by-limit-performance-optimization/","title":"Mysql 的深分页问题及优化方法"},{"content":"常用命令 hugo new site SITE_NAME 生成静态博客项目 hugo server 启动本地服务器，加上 -D 可以渲染 draft=true 的文章 hugo new post/new-content.md 在 post 下新建一篇文章 hugo 生成站点静态文件(public 和 resources 目录) hugo list drafts/expired/future 列出草稿/过期/未来的文件 踩坑记 使用主题 Event 时, 文章必须放在 content/**post**/ 目录下, 否则 Home 页不会展示文章链接, 文章内也不会展示目录 使用主题 Zzo 时, 要创建 Archive 页(类似 Event 中的 Home 页), 需要创建文件 content/archive/_index.md(参考 How to automatically generate archive page content #47) 使用主题 Zzo 时, 在 GigHub Actions 配置中必须启用 Hugo extended 模式, 否则构建会失败(参考Hugo setup) 参考链接 Hugo 官方文档 Hugo 从入门到会用 Hugo 搭建博客实践 Hugo+Stack 博客修改记录 hugo升级与hugo-theme-stack主题修改与最后修改时间问题 ","date":"2022-10-30T22:22:52+08:00","permalink":"https://zhumengzhu.github.io/2022/10/hugo-quick-start/","title":"Hugo 配置记录"},{"content":"Mac 客户端 推荐 V2rayU Terminal 代理 1 2 # .config/fish/config.fish alias all_proxy=\u0026#39;export http_proxy=http://127.0.0.1:1087;export https_proxy=http://127.0.0.1:1087;export ALL_PROXY=socks5://127.0.0.1:1080\u0026#39; git ssh 代理 1 2 3 4 # .ssh/config Host github.com User git ProxyCommand nc -v -x 127.0.0.1:1080 %h %p ","date":"2022-10-16T19:09:32+08:00","permalink":"https://zhumengzhu.github.io/2022/10/how-to-set-network-proxy/","title":"代理设置"}]